using System.Collections.Concurrent;
using System.Security.AccessControl;
using DokanNet;
using FtpVirtualDrive.Core.Interfaces;
using FtpVirtualDrive.Core.Models;
using Microsoft.Extensions.Logging;
using FileAccess = DokanNet.FileAccess;

namespace FtpVirtualDrive.Infrastructure.VirtualFileSystem;

/// <summary>
/// Virtual file system implementation using Dokan.Net to mount FTP as a local drive
/// </summary>
public class FtpVirtualFileSystem : IDokanOperations, IVirtualDrive
{
    private readonly ILogger<FtpVirtualFileSystem> _logger;
    private readonly IFileSyncService _syncService;
    private readonly IVersionTracker _versionTracker;
    private readonly IActivityLogger _activityLogger;
    
    private IFtpClient? _ftpClient;
    private DokanInstance? _dokanInstance;
    private readonly ConcurrentDictionary<string, CachedFileInfo> _fileCache = new();
    private readonly ConcurrentDictionary<string, Stream> _openFiles = new();
    private bool _disposed;

    public bool IsMounted { get; private set; }
    public string? MountedDriveLetter { get; private set; }
    public string? MountPath { get; private set; }

    public event EventHandler<VirtualFileSystemEventArgs>? FileOperation;
    public event EventHandler<MountStatusEventArgs>? MountStatusChanged;

    public FtpVirtualFileSystem(
        ILogger<FtpVirtualFileSystem> logger,
        IFileSyncService syncService,
        IVersionTracker versionTracker,
        IActivityLogger activityLogger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _syncService = syncService ?? throw new ArgumentNullException(nameof(syncService));
        _versionTracker = versionTracker ?? throw new ArgumentNullException(nameof(versionTracker));
        _activityLogger = activityLogger ?? throw new ArgumentNullException(nameof(activityLogger));
    }

    public async Task<bool> MountAsync(string driveLetter, IFtpClient ftpClient)
    {
        if (IsMounted)
        {
            _logger.LogWarning("Virtual drive is already mounted");
            return false;
        }

        if (!ftpClient.IsConnected)
        {
            _logger.LogError("FTP client is not connected");
            return false;
        }

        try
        {
            _ftpClient = ftpClient;
            MountedDriveLetter = driveLetter.ToUpper() + ":";
            MountPath = MountedDriveLetter + "\\";

            var dokanOptions = new DokanOptions
            {
                DriveLetter = driveLetter[0],
                ThreadCount = 5,
                Options = DokanOption.EnableNotificationAPI | DokanOption.MountOnDrive,
                Timeout = TimeSpan.FromSeconds(30),
                AllocationUnitSize = 512,
                SectorSize = 512
            };

            // Start Dokan in a background task
            _ = Task.Run(() =>
            {
                try
                {
                    _dokanInstance = new DokanInstance();
                    var result = _dokanInstance.Mount(this, dokanOptions);
                    
                    if (result != DokanStatus.Success)
                    {
                        _logger.LogError("Failed to mount virtual drive. Dokan status: {Status}", result);
                        OnMountStatusChanged(false, null, $"Mount failed: {result}");
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error during Dokan mount operation");
                    OnMountStatusChanged(false, null, ex.Message);
                }
            });

            // Give it a moment to initialize
            await Task.Delay(1000);

            IsMounted = true;
            _logger.LogInformation("Successfully mounted FTP as virtual drive {DriveLetter}", MountedDriveLetter);

            await _activityLogger.LogActivityAsync(ActivityLog.CreateSuccess(
                OperationType.Connect,
                MountedDriveLetter,
                "Virtual drive mounted successfully",
                _ftpClient.ConnectionInfo?.Username));

            OnMountStatusChanged(true, MountedDriveLetter, null);
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to mount virtual drive {DriveLetter}", driveLetter);
            OnMountStatusChanged(false, null, ex.Message);
            return false;
        }
    }

    public async Task<bool> UnmountAsync()
    {
        if (!IsMounted)
            return true;

        try
        {
            _dokanInstance?.Dispose();
            _dokanInstance = null;

            // Clean up open files
            foreach (var openFile in _openFiles.Values)
            {
                openFile.Dispose();
            }
            _openFiles.Clear();
            _fileCache.Clear();

            var driveLetter = MountedDriveLetter;
            IsMounted = false;
            MountedDriveLetter = null;
            MountPath = null;

            _logger.LogInformation("Successfully unmounted virtual drive {DriveLetter}", driveLetter);

            await _activityLogger.LogActivityAsync(ActivityLog.CreateSuccess(
                OperationType.Disconnect,
                driveLetter ?? "Unknown",
                "Virtual drive unmounted successfully",
                _ftpClient?.ConnectionInfo?.Username));

            OnMountStatusChanged(false, null, null);
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to unmount virtual drive");
            OnMountStatusChanged(false, null, ex.Message);
            return false;
        }
    }

    public async Task<IEnumerable<string>> GetAvailableDriveLettersAsync()
    {
        return await Task.Run(() =>
        {
            var usedLetters = DriveInfo.GetDrives().Select(d => d.Name[0]).ToHashSet();
            var availableLetters = new List<string>();

            for (char letter = 'Z'; letter >= 'C'; letter--)
            {
                if (!usedLetters.Contains(letter))
                {
                    availableLetters.Add(letter.ToString());
                }
            }

            return availableLetters;
        });
    }

    #region IDokanOperations Implementation

    public NtStatus CreateFile(string fileName, FileAccess access, FileShare share, FileMode mode,
        FileOptions options, FileAttributes attributes, IDokanFileInfo info)
    {
        try
        {
            var operation = mode switch
            {
                FileMode.Create => OperationType.Create,
                FileMode.CreateNew => OperationType.Create,
                _ => OperationType.Open
            };

            _logger.LogDebug("CreateFile: {FileName}, Mode: {Mode}, Access: {Access}", fileName, mode, access);

            // Handle directory operations
            if (info.IsDirectory)
            {
                return HandleDirectoryOperation(fileName, mode, operation);
            }

            // Handle file operations
            return HandleFileOperation(fileName, mode, access, operation);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in CreateFile for {FileName}", fileName);
            return NtStatus.Error;
        }
    }

    public NtStatus ReadFile(string fileName, byte[] buffer, out int bytesRead, long offset, IDokanFileInfo info)
    {
        bytesRead = 0;

        try
        {
            if (!_openFiles.TryGetValue(fileName, out var stream))
            {
                // File not in cache, download from FTP
                var ftpStream = _ftpClient!.DownloadFileAsync(fileName).Result;
                _openFiles[fileName] = ftpStream;
                stream = ftpStream;

                _ = Task.Run(async () =>
                {
                    await _activityLogger.LogActivityAsync(ActivityLog.CreateSuccess(
                        OperationType.Download, fileName, $"Downloaded for read access", 
                        _ftpClient.ConnectionInfo?.Username, stream.Length));
                });
            }

            stream.Position = offset;
            bytesRead = await stream.ReadAsync(buffer.AsMemory(0, buffer.Length));

            return NtStatus.Success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error reading file {FileName} at offset {Offset}", fileName, offset);
            return NtStatus.Error;
        }
    }

    public NtStatus WriteFile(string fileName, byte[] buffer, out int bytesWritten, long offset, IDokanFileInfo info)
    {
        bytesWritten = 0;

        try
        {
            if (!_openFiles.TryGetValue(fileName, out var stream))
            {
                // Create new stream for writing
                stream = new MemoryStream();
                _openFiles[fileName] = stream;
            }

            if (stream.Length < offset)
            {
                // Extend stream if necessary
                stream.SetLength(offset);
            }

            stream.Position = offset;
            await stream.WriteAsync(buffer.AsMemory(0, buffer.Length));
            bytesWritten = buffer.Length;

            // Mark file as modified
            _fileCache.AddOrUpdate(fileName, 
                new CachedFileInfo { LastModified = DateTime.UtcNow, IsModified = true },
                (key, existing) => existing with { LastModified = DateTime.UtcNow, IsModified = true });

            return NtStatus.Success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error writing to file {FileName} at offset {Offset}", fileName, offset);
            return NtStatus.Error;
        }
    }

    public NtStatus GetFileInformation(string fileName, out FileInformation fileInfo, IDokanFileInfo info)
    {
        fileInfo = new FileInformation();

        try
        {
            if (_fileCache.TryGetValue(fileName, out var cached))
            {
                fileInfo = cached.ToFileInformation();
                return NtStatus.Success;
            }

            // Get file info from FTP server
            var ftpFileInfo = _ftpClient!.GetFileInfoAsync(fileName).Result;
            if (ftpFileInfo == null)
                return NtStatus.ObjectNameNotFound;

            fileInfo = new FileInformation
            {
                FileName = ftpFileInfo.Name,
                Length = ftpFileInfo.Size,
                LastWriteTime = ftpFileInfo.LastModified,
                LastAccessTime = ftpFileInfo.LastModified,
                CreationTime = ftpFileInfo.LastModified,
                Attributes = ftpFileInfo.IsDirectory ? FileAttributes.Directory : FileAttributes.Normal
            };

            // Cache the file info
            _fileCache[fileName] = new CachedFileInfo
            {
                Name = ftpFileInfo.Name,
                Size = ftpFileInfo.Size,
                LastModified = ftpFileInfo.LastModified,
                IsDirectory = ftpFileInfo.IsDirectory
            };

            return NtStatus.Success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting file information for {FileName}", fileName);
            return NtStatus.Error;
        }
    }

    public NtStatus FindFiles(string fileName, out IList<FileInformation> files, IDokanFileInfo info)
    {
        files = new List<FileInformation>();

        try
        {
            var ftpFiles = _ftpClient!.ListDirectoryAsync(fileName).Result;
            
            foreach (var ftpFile in ftpFiles)
            {
                files.Add(new FileInformation
                {
                    FileName = ftpFile.Name,
                    Length = ftpFile.Size,
                    LastWriteTime = ftpFile.LastModified,
                    LastAccessTime = ftpFile.LastModified,
                    CreationTime = ftpFile.LastModified,
                    Attributes = ftpFile.IsDirectory ? FileAttributes.Directory : FileAttributes.Normal
                });
            }

            return NtStatus.Success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error finding files in {FileName}", fileName);
            return NtStatus.Error;
        }
    }

    public void CleanupFile(string fileName, IDokanFileInfo info)
    {
        try
        {
            if (_openFiles.TryRemove(fileName, out var stream))
            {
                // Save changes before closing if file was modified
                if (_fileCache.TryGetValue(fileName, out var cached) && cached.IsModified)
                {
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            stream.Position = 0;
                            await _ftpClient!.UploadFileAsync(fileName, stream);
                            
                            // Save version
                            var content = ((MemoryStream)stream).ToArray();
                            var hash = _versionTracker.CalculateContentHash(content);
                            await _versionTracker.SaveVersionAsync(fileName, content, hash);

                            await _activityLogger.LogActivityAsync(ActivityLog.CreateSuccess(
                                OperationType.Modify, fileName, "File modified and uploaded",
                                _ftpClient.ConnectionInfo?.Username, content.Length));

                            OnFileOperation(new VirtualFileSystemEventArgs
                            {
                                FilePath = fileName,
                                Operation = OperationType.Modify,
                                Success = true
                            });
                        }
                        catch (Exception ex)
                        {
                            _logger.LogError(ex, "Failed to sync modified file {FileName}", fileName);
                            
                            OnFileOperation(new VirtualFileSystemEventArgs
                            {
                                FilePath = fileName,
                                Operation = OperationType.Modify,
                                Success = false,
                                ErrorMessage = ex.Message
                            });
                        }
                    });
                }

                stream.Dispose();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during cleanup of file {FileName}", fileName);
        }
    }

    public void CloseFile(string fileName, IDokanFileInfo info)
    {
        // File is closed, but cleanup will handle the actual disposal
        _logger.LogDebug("CloseFile called for {FileName}", fileName);
    }

    public NtStatus DeleteFile(string fileName, IDokanFileInfo info)
    {
        try
        {
            var success = _ftpClient!.DeleteFileAsync(fileName).Result;
            if (!success)
                return NtStatus.Error;

            _fileCache.TryRemove(fileName, out _);
            _openFiles.TryRemove(fileName, out var stream);
            stream?.Dispose();

            _ = Task.Run(async () =>
            {
                await _activityLogger.LogActivityAsync(ActivityLog.CreateSuccess(
                    OperationType.Delete, fileName, "File deleted",
                    _ftpClient.ConnectionInfo?.Username));
            });

            OnFileOperation(new VirtualFileSystemEventArgs
            {
                FilePath = fileName,
                Operation = OperationType.Delete,
                Success = true
            });

            return NtStatus.Success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting file {FileName}", fileName);
            return NtStatus.Error;
        }
    }

    public NtStatus MoveFile(string oldName, string newName, bool replace, IDokanFileInfo info)
    {
        try
        {
            // Download, upload to new location, delete old
            var stream = _ftpClient!.DownloadFileAsync(oldName).Result;
            var uploadSuccess = _ftpClient.UploadFileAsync(newName, stream).Result;
            
            if (uploadSuccess)
            {
                var deleteSuccess = _ftpClient.DeleteFileAsync(oldName).Result;
                if (deleteSuccess)
                {
                    _fileCache.TryRemove(oldName, out _);
                    
                    _ = Task.Run(async () =>
                    {
                        await _activityLogger.LogActivityAsync(ActivityLog.CreateSuccess(
                            OperationType.Move, $"{oldName} -> {newName}", "File moved",
                            _ftpClient.ConnectionInfo?.Username));
                    });

                    return NtStatus.Success;
                }
            }

            return NtStatus.Error;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error moving file from {OldName} to {NewName}", oldName, newName);
            return NtStatus.Error;
        }
    }

    public NtStatus SetFileAttributes(string fileName, FileAttributes attributes, IDokanFileInfo info)
    {
        // FTP doesn't typically support setting attributes directly
        return NtStatus.Success;
    }

    public NtStatus SetFileTime(string fileName, DateTime? creationTime, DateTime? lastAccessTime,
        DateTime? lastWriteTime, IDokanFileInfo info)
    {
        // FTP doesn't typically support setting file times directly
        return NtStatus.Success;
    }

    public NtStatus GetDiskFreeSpace(out long freeBytesAvailable, out long totalNumberOfBytes,
        out long totalNumberOfFreeBytes, IDokanFileInfo info)
    {
        // Return large values for virtual drive
        freeBytesAvailable = 1024L * 1024L * 1024L * 1024L; // 1TB
        totalNumberOfBytes = 1024L * 1024L * 1024L * 1024L; // 1TB
        totalNumberOfFreeBytes = 1024L * 1024L * 1024L * 1024L; // 1TB
        return NtStatus.Success;
    }

    public NtStatus GetVolumeInformation(out string volumeLabel, out FileSystemFeatures features,
        out string fileSystemName, out uint maximumComponentLength, IDokanFileInfo info)
    {
        volumeLabel = $"FTP Drive ({_ftpClient?.ConnectionInfo?.Host})";
        features = FileSystemFeatures.None;
        fileSystemName = "FTPFS";
        maximumComponentLength = 256;
        return NtStatus.Success;
    }

    public NtStatus GetFileSecurity(string fileName, out FileSystemSecurity? security,
        AccessControlSections sections, IDokanFileInfo info)
    {
        security = null;
        return NtStatus.NotImplemented;
    }

    public NtStatus SetFileSecurity(string fileName, FileSystemSecurity security,
        AccessControlSections sections, IDokanFileInfo info)
    {
        return NtStatus.NotImplemented;
    }

    public NtStatus Mounted(string mountPoint, IDokanFileInfo info)
    {
        _logger.LogInformation("Virtual drive mounted at {MountPoint}", mountPoint);
        return NtStatus.Success;
    }

    public NtStatus Unmounted(IDokanFileInfo info)
    {
        _logger.LogInformation("Virtual drive unmounted");
        return NtStatus.Success;
    }

    public NtStatus FindStreams(string fileName, out IList<FileInformation> streams, IDokanFileInfo info)
    {
        streams = new List<FileInformation>();
        return NtStatus.NotImplemented;
    }

    public void Cleanup(string fileName, IDokanFileInfo info)
    {
        CleanupFile(fileName, info);
    }

    public NtStatus FlushFileBuffers(string fileName, IDokanFileInfo info)
    {
        return NtStatus.Success;
    }

    public NtStatus FindFilesWithPattern(string fileName, string searchPattern, out IList<FileInformation> files, IDokanFileInfo info)
    {
        return FindFiles(fileName, out files, info);
    }

    public NtStatus DeleteDirectory(string fileName, IDokanFileInfo info)
    {
        try
        {
            var success = _ftpClient!.DeleteFileAsync(fileName).Result;
            return success ? NtStatus.Success : NtStatus.Error;
        }
        catch
        {
            return NtStatus.Error;
        }
    }

    public NtStatus SetEndOfFile(string fileName, long length, IDokanFileInfo info)
    {
        try
        {
            if (_openFiles.TryGetValue(fileName, out var stream))
            {
                stream.SetLength(length);
                return NtStatus.Success;
            }
            return NtStatus.ObjectNameNotFound;
        }
        catch
        {
            return NtStatus.Error;
        }
    }

    public NtStatus SetAllocationSize(string fileName, long length, IDokanFileInfo info)
    {
        // Not applicable for FTP
        return NtStatus.Success;
    }

    public NtStatus LockFile(string fileName, long offset, long length, IDokanFileInfo info)
    {
        // File locking not supported in FTP
        return NtStatus.NotImplemented;
    }

    public NtStatus UnlockFile(string fileName, long offset, long length, IDokanFileInfo info)
    {
        // File unlocking not supported in FTP
        return NtStatus.NotImplemented;
    }

    #endregion

    #region Helper Methods

    private NtStatus HandleDirectoryOperation(string dirName, FileMode mode, OperationType operation)
    {
        try
        {
            if (mode == FileMode.Create || mode == FileMode.CreateNew)
            {
                var success = _ftpClient!.CreateDirectoryAsync(dirName).Result;
                return success ? NtStatus.Success : NtStatus.Error;
            }

            return NtStatus.Success;
        }
        catch
        {
            return NtStatus.Error;
        }
    }

    private NtStatus HandleFileOperation(string fileName, FileMode mode, FileAccess access, OperationType operation)
    {
        try
        {
            if (mode == FileMode.Create || mode == FileMode.CreateNew)
            {
                // Create new empty file
                _openFiles[fileName] = new MemoryStream();
                _fileCache[fileName] = new CachedFileInfo
                {
                    Name = Path.GetFileName(fileName),
                    Size = 0,
                    LastModified = DateTime.UtcNow,
                    IsModified = true
                };
            }
            else if (access.HasFlag(FileAccess.ReadData) && !_openFiles.ContainsKey(fileName))
            {
                // Download file for reading
                try
                {
                    var stream = _ftpClient!.DownloadFileAsync(fileName).Result;
                    _openFiles[fileName] = stream;
                }
                catch
                {
                    return NtStatus.ObjectNameNotFound;
                }
            }

            return NtStatus.Success;
        }
        catch
        {
            return NtStatus.Error;
        }
    }

    private void OnFileOperation(VirtualFileSystemEventArgs args)
    {
        FileOperation?.Invoke(this, args);
    }

    private void OnMountStatusChanged(bool isMounted, string? driveLetter, string? errorMessage)
    {
        MountStatusChanged?.Invoke(this, new MountStatusEventArgs
        {
            IsMounted = isMounted,
            DriveLetter = driveLetter,
            ErrorMessage = errorMessage
        });
    }

    #endregion

    public void Dispose()
    {
        if (_disposed) return;

        try
        {
            _ = UnmountAsync();
            
            foreach (var stream in _openFiles.Values)
            {
                stream.Dispose();
            }
            _openFiles.Clear();
            _fileCache.Clear();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error disposing virtual file system");
        }

        _disposed = true;
        GC.SuppressFinalize(this);
    }
}

/// <summary>
/// Cached file information for performance
/// </summary>
internal record CachedFileInfo
{
    public string Name { get; init; } = string.Empty;
    public long Size { get; init; }
    public DateTime LastModified { get; init; }
    public bool IsDirectory { get; init; }
    public bool IsModified { get; init; }

    public FileInformation ToFileInformation()
    {
        return new FileInformation
        {
            FileName = Name,
            Length = Size,
            LastWriteTime = LastModified,
            LastAccessTime = LastModified,
            CreationTime = LastModified,
            Attributes = IsDirectory ? FileAttributes.Directory : FileAttributes.Normal
        };
    }
}
